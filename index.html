<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048游戏</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #faf8ef;
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
            margin: 0;
            padding: 20px;
            color: #776e65;
        }
        
        .container {
            width: 470px;
            margin: 20px auto;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 70px;
            font-weight: bold;
            margin: 0;
            color: #776e65;
            line-height: 1;
        }
        
        .score-container {
            position: relative;
            background: #bbada0;
            padding: 12px 25px;
            border-radius: 6px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
            min-width: 70px;
        }
        
        .score-container #score {
            display: block;
            font-size: 28px;
            margin-top: 5px;
        }
        
        .new-game {
            background: #8f7a66;
            color: #f9f6f2;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            transition: background-color 0.2s ease;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
            display: block;
            width: 130px;
            text-align: center;
        }
        
        .new-game:hover {
            background: #7f6a56;
        }
        
        .grid-container {
            background: #bbada0;
            padding: 15px;
            border-radius: 8px;
            width: 470px;
            height: 470px;
            position: relative;
            box-sizing: border-box;
            box-shadow: 0 5px 0 rgba(0,0,0,0.1);
        }
        
        .grid-row {
            display: flex;
            margin-bottom: 15px;
            height: 100px;
        }
        
        .grid-row:last-child {
            margin-bottom: 0;
        }
        
        .grid-cell {
            width: 100px;
            height: 100px;
            margin-right: 15px;
            background: rgba(238, 228, 218, 0.35);
            border-radius: 6px;
            position: relative;
        }
        
        .grid-cell:last-child {
            margin-right: 0;
        }
        
        .tile {
            position: absolute;
            top: 0;
            left: 0;
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 45px;
            font-weight: bold;
            background: #eee4da;
            border-radius: 6px;
            transition: transform 0.15s cubic-bezier(0.22, 1, 0.36, 1);
            will-change: transform;
        }
        
        .tile.tile-new {
            animation: appear 0.2s ease-out;
        }
        
        .tile.tile-merged {
            z-index: 2;
            animation: merge 0.2s ease-out;
        }
        .tile.tile-moving {
            z-index: 3;
            transition: transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }
        .tile.move-left { transform: translateX(-100%); }
        .tile.move-right { transform: translateX(100%); }
        .tile.move-up { transform: translateY(-100%); }
        .tile.move-down { transform: translateY(100%); }
        .tile.tile-2 { background: #eee4da; color: #776e65; }
        .tile.tile-4 { background: #ede0c8; color: #776e65; }
        .tile.tile-8 { background: #f2b179; color: #f9f6f2; }
        .tile.tile-16 { background: #f59563; color: #f9f6f2; }
        .tile.tile-32 { background: #f67c5f; color: #f9f6f2; }
        .tile.tile-64 { background: #f65e3b; color: #f9f6f2; }
        .tile.tile-128 { 
            background: #edcf72; 
            color: #f9f6f2;
            font-size: 30px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1), inset 0 0 20px rgba(255,255,255,0.2);
        }
        .tile.tile-256 { 
            background: #edcc61; 
            color: #f9f6f2;
            font-size: 30px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1), inset 0 0 20px rgba(255,255,255,0.2);
        }
        .tile.tile-512 { 
            background: #edc850; 
            color: #f9f6f2;
            font-size: 30px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1), inset 0 0 20px rgba(255,255,255,0.2);
        }
        .tile.tile-1024 { 
            background: #edc53f; 
            color: #f9f6f2;
            font-size: 25px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1), inset 0 0 20px rgba(255,255,255,0.2);
        }
        .tile.tile-2048 { 
            background: #edc22e; 
            color: #f9f6f2;
            font-size: 25px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1), inset 0 0 20px rgba(255,255,255,0.3);
        }
        @keyframes appear {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            50% {
                opacity: 0.9;
                transform: scale(1.1);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        @keyframes merge {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>2048</h1>
            <div class="score-container">
                分数: <span id="score">0</span>
            </div>
        </div>
        <button class="new-game" onclick="newGame()">新游戏</button>
        <div class="grid-container" id="grid"></div>
    </div>

    <script>
        console.log('脚本开始执行');
        let grid = [];
        let score = 0;
        let moved = false;
        let lastAddedTile = null;
        let mergedTiles = [];
        let movedFromPositions = [];

        // 将事件监听器移到这里
        window.addEventListener('load', () => {
            console.log('页面加载完成，添加键盘事件监听器');
            document.addEventListener('keydown', (e) => {
                console.log('按键被按下:', e.key);
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        move('left');
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        move('right');
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        move('up');
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        move('down');
                        break;
                }
            });
        });

        function initGrid() {
            moved = false;
            lastAddedTile = null;
            mergedTiles = [];
            grid = [];
            
            // 初始化网格数组
            for (let i = 0; i < 4; i++) {
                grid[i] = [];
                for (let j = 0; j < 4; j++) {
                    grid[i][j] = 0;
                }
            }
            
            console.log('初始化网格:', JSON.stringify(grid));
            
            // 更新显示
            updateDisplay();
        }

        function updateDisplay() {
            const container = document.getElementById('grid');
            container.innerHTML = '';
            
            // 创建网格
            for (let i = 0; i < 4; i++) {
                const row = document.createElement('div');
                row.className = 'grid-row';
                
                for (let j = 0; j < 4; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.setAttribute('data-row', i);
                    cell.setAttribute('data-col', j);
                    
                    if (grid[i][j] !== 0) {
                        const tile = document.createElement('div');
                        tile.className = `tile tile-${grid[i][j]}`;
                        tile.textContent = grid[i][j];
                        
                        // 查找这个数字是否是从其他位置移动过来的
                        const movedFrom = movedFromPositions.find(
                            pos => pos.value === grid[i][j] && pos.toRow === i && pos.toCol === j
                        );
                        
                        if (movedFrom) {
                            // 计算移动距离
                            const dx = (movedFrom.fromCol - j) * 115;
                            const dy = (movedFrom.fromRow - i) * 115;
                            
                            // 设置初始位置
                            tile.style.transform = `translate(${dx}px, ${dy}px)`;
                            
                            // 强制重绘
                            tile.offsetHeight;
                            
                            // 移动到目标位置
                            tile.style.transform = 'translate(0, 0)';
                        }
                        
                        // 合并动画
                        if (mergedTiles.some(t => t.row === i && t.col === j)) {
                            setTimeout(() => {
                                tile.classList.add('tile-merged');
                            }, 150);
                        }
                        
                        // 新数字动画
                        if (lastAddedTile && i === lastAddedTile.x && j === lastAddedTile.y) {
                            tile.classList.add('tile-new');
                        }
                        
                        cell.appendChild(tile);
                    }
                    
                    row.appendChild(cell);
                }
                
                container.appendChild(row);
            }
        }

        function addNewTile() {
            const emptyCells = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (grid[i][j] === 0) {
                        emptyCells.push({x: i, y: j});
                    }
                }
            }
            if (emptyCells.length > 0) {
                const position = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const value = Math.random() < 0.9 ? 2 : 4;
                grid[position.x][position.y] = value;
                moved = true;  // 设置moved状态为true，因为添加了新数字
                
                // 保存最后添加的数字块信息，用于动画
                lastAddedTile = {
                    x: position.x,
                    y: position.y,
                    value: value
                };
                
                console.log('添加新数字，位置:', position.x, position.y, '值:', value);
                console.log('更新后的网格:', JSON.stringify(grid));
            }
        }

        function move(direction) {
            console.log('move函数被调用，方向:', direction);
            moved = false;
            
            // 保存移动前的网格状态，用于后续动画判断
            const previousGrid = grid.map(row => [...row]);
            
            // 创建新的网格并复制当前网格
            const newGrid = grid.map(row => [...row]);
            console.log('当前网格状态:', JSON.stringify(grid));
            
            // 处理一行或一列的移动和合并
            function processLine(line, reverse = false) {
                // 记录原始状态
                const originalLine = [...line];
                console.log('处理前:', JSON.stringify(originalLine), reverse ? '(反转)' : '');
                
                // 如果需要反转（向右或向下移动），先反转数组
                if (reverse) {
                    line = [...line].reverse();
                }
                
                // 移除所有的0
                let numbers = line.filter(n => n !== 0);
                console.log('去除0后:', JSON.stringify(numbers));
                
                // 合并相同的数字
                for (let i = 0; i < numbers.length - 1;) {
                    if (numbers[i] === numbers[i + 1]) {
                        numbers[i] *= 2;
                        score += numbers[i];
                        document.getElementById('score').textContent = score;
                        numbers.splice(i + 1, 1);
                        moved = true;
                    } else {
                        i++;
                    }
                }
                console.log('合并后:', JSON.stringify(numbers));
                
                // 补充0到4个位置
                while (numbers.length < 4) {
                    numbers.push(0);
                }
                
                // 如果是反向移动，再次反转结果
                if (reverse) {
                    numbers.reverse();
                }
                
                console.log('处理后:', JSON.stringify(numbers));
                
                // 检查是否发生了变化
                const hasChanged = !originalLine.every((val, idx) => val === numbers[idx]);
                if (hasChanged) {
                    moved = true;
                }
                
                return numbers;
            }
            
            // 处理移动
            if (direction === 'left' || direction === 'right') {
                // 处理每一行
                for (let i = 0; i < 4; i++) {
                    newGrid[i] = processLine([...grid[i]], direction === 'right');
                    console.log(`第${i+1}行处理结果:`, JSON.stringify(newGrid[i]));
                }
            } else {
                // 处理每一列
                for (let j = 0; j < 4; j++) {
                    // 提取列
                    const column = grid.map(row => row[j]);
                    // 处理列
                    const newColumn = processLine(column, direction === 'down');
                    // 将处理后的列放回网格
                    for (let i = 0; i < 4; i++) {
                        newGrid[i][j] = newColumn[i];
                    }
                    console.log(`第${j+1}列处理结果:`, JSON.stringify(newColumn));
                }
            }
            
            // 跟踪数字的移动
            // 在move函数中，替换移动跟踪部分
            movedFromPositions = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (previousGrid[i][j] !== 0) {
                        // 查找这个数字移动到了哪里
                        for (let newI = 0; newI < 4; newI++) {
                            for (let newJ = 0; newJ < 4; newJ++) {
                                if (newGrid[newI][newJ] === previousGrid[i][j] && 
                                    (i !== newI || j !== newJ)) {
                                    movedFromPositions.push({
                                        value: previousGrid[i][j],
                                        fromRow: i,
                                        fromCol: j,
                                        toRow: newI,
                                        toCol: newJ
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // 检查是否有任何变化
            const hasChanges = grid.some((row, i) => 
                row.some((val, j) => {
                    // 如果值改变，记录这个数字是从哪里移动过来的
                    if (val !== 0 && val !== newGrid[i][j]) {
                        // 查找这个值在新网格中的位置
                        for (let newI = 0; newI < 4; newI++) {
                            for (let newJ = 0; newJ < 4; newJ++) {
                                if (newGrid[newI][newJ] === val) {
                                    movedFromPositions.push({
                                        value: val,
                                        fromRow: i,
                                        fromCol: j,
                                        toRow: newI,
                                        toCol: newJ
                                    });
                                    break;
                                }
                            }
                        }
                    }
                    return val !== newGrid[i][j];
                })
            );
            
            if (hasChanges || moved) {
                console.log('网格发生变化');
                
                // 保存合并的信息
                mergedTiles = [];
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        // 检测合并：如果新位置的值是旧位置值的2倍
                        if (newGrid[i][j] !== 0 && previousGrid[i][j] !== newGrid[i][j] && 
                            newGrid[i][j] / 2 === previousGrid[i][j]) {
                            mergedTiles.push({row: i, col: j, value: newGrid[i][j]});
                        }
                    }
                }
                
                grid = newGrid.map(row => [...row]);  // 深拷贝新网格
                addNewTile();
                updateDisplay();
                checkGameOver();
            } else {
                console.log('网格未发生变化');
            }
        }

        function checkGameOver() {
            // 检查是否有空格
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (grid[i][j] === 0) return;
                }
            }

            // 检查是否可以合并
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (j < 3 && grid[i][j] === grid[i][j + 1]) return;
                    if (i < 3 && grid[i][j] === grid[i + 1][j]) return;
                }
            }

            alert('游戏结束！最终得分：' + score);
        }

        function newGame() {
            score = 0;
            moved = false;  // 重置moved变量
            document.getElementById('score').textContent = score;
            initGrid();
            addNewTile();
            addNewTile();
            updateDisplay();
            console.log('新游戏开始，当前网格:', grid);  // 添加调试日志
        }

        // 添加触摸支持
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        document.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) move('right');
                else move('left');
            } else {
                if (deltaY > 0) move('down');
                else move('up');
            }
        });

        // 开始新游戏
        newGame();
    </script>
</body>
</html>